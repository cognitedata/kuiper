use crate::{
    lexer::Token,
    lexer::LexerError,
    parse::ast,
    expressions::{Operator, UnaryOperator},
};
use logos::Span;

grammar;

Const: ast::Constant = {
    <val:"int"> => {
        ast::Constant::NegativeInteger(val)
    },
    <val:"uint"> => {
        ast::Constant::PositiveInteger(val)
    },
    <val:"string"> => {
        ast::Constant::String(val)
    },
    <val:"float"> => {
        ast::Constant::Float(val)
    },
    <val:"bool"> => {
        ast::Constant::Bool(val)
    },
    "null" => {
        ast::Constant::Null
    }
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Spanned<T>: (T, Span) = {
    <start:@L> <e:T> <end:@R> => (e, Span { start, end })
}

FunctionArg: ast::FunctionParameter = {
    <start:@L> "(" <args: Comma<"var">> ")=>" <e: Expr> <end:@R> => ast::FunctionParameter::Lambda {
        args,
        inner: e,
        loc: Span { start, end }
    },
    <start:@L> <v:"var"> "=>" <e:Expr> <end:@R> => ast::FunctionParameter::Lambda {
        args: vec![v],
        inner: e,
        loc: Span { start, end }
    },
    <e: Expr> => ast::FunctionParameter::Expression(e)
}

pub Expr: ast::Expression = Op2Expr;

Pair: (ast::Expression, ast::Expression) = {
    <lh:Expr> ":" <rh:Expr> => (lh, rh)
}

Selector: ast::Selector = {
    "." <start:@L> <el:"var"> <end:@R> => ast::Selector::String(el, Span { start, end }),
    "[" <el:Expr> "]" => ast::Selector::Expression(Box::new(el))
}

Literal: String = {
    <fun:"var"> => fun,
    <fun:"type"> => fun.to_string()
}

Term: ast::Expression = {
    <val:Spanned<Const>> => ast::Expression::Constant(val.0, val.1),
    <start:@L> <fun:Literal> "(" <args:Comma<FunctionArg>> ")" <end:@R> => ast::Expression::Function {
        name: fun,
        args,
        loc: Span { start, end }
    },
    <var:Spanned<"var">> => ast::Expression::Variable(var.0, var.1),
    <start:@L> "[" <it:Comma<Expr>> "]" <end:@R> => ast::Expression::Array(it, Span { start, end }),
    <start:@L> "{" <it:Comma<Pair>> "}" <end:@R> => ast::Expression::Object(it, Span { start, end }),
    <e: Term> "." <start:@L> <fun:Literal> "(" <mut args:Comma<FunctionArg>> ")" <end:@R> => {
        args.insert(0, ast::FunctionParameter::Expression(e));
        ast::Expression::Function {
            name: fun,
            args,
            loc: Span { start, end }
        }
    },
    <e: Term> <start:@L> <sel:Selector> <end:@R> => ast::Expression::Selector {
        lhs: Box::new(e),
        sel,
        loc: Span { start, end }
    },
    "(" <e:Expr> ")" => e
}

Tier<Op, NextTier>: ast::Expression = {
    <lhs:Tier<Op, NextTier>> <op:Spanned<Op>> <rhs:NextTier> => ast::Expression::BinaryOperation(ast::OpExpression {
        lhs: Box::new(lhs),
        operator: op.0,
        rhs: Box::new(rhs)
    }, op.1),
    NextTier
}

// From least to most important
Op2Expr = Tier<Op2, Op3Expr>;
Op2: Operator = {
    "||" => Operator::Or
}

Op3Expr = Tier<Op3, Op4Expr>;
Op3: Operator = {
    "&&" => Operator::And
}

Op4Expr = Tier<Op4, Op5Expr>;
Op4: Operator = {
    "==" => Operator::Equals,
    "!=" => Operator::NotEquals
}

Op5Expr: ast::Expression = {
    <lhs:Op5Expr> <op:Spanned<Op5>> <rhs:Op6Expr> => ast::Expression::BinaryOperation(ast::OpExpression {
        lhs: Box::new(lhs),
        operator: op.0,
        rhs: Box::new(rhs)
    }, op.1),
    <lhs:Op5Expr> "is" <rhs:"type"> => ast::Expression::Is(ast::IsExpression {
        lhs: Box::new(lhs),
        rhs,
    }),
    Op6Expr
}

Op5: Operator = {
    ">" => Operator::GreaterThan,
    "<" => Operator::LessThan,
    ">=" => Operator::GreaterThanEquals,
    "<=" => Operator::LessThanEquals,
}

Op6Expr = Tier<Op6, Op7Expr>;
Op6: Operator = {
    "+" => Operator::Plus,
    "-" => Operator::Minus
}

Op7Expr = Tier<Op7, Op8Expr>;
Op7: Operator = {
    "*" => Operator::Multiply,
    "/" => Operator::Divide,
    "%" => Operator::Modulo
}
Op8Expr: ast::Expression = {
    <start:@L> "!" <end:@R> <e:Op8Expr> => ast::Expression::UnaryOperation {
        operator: UnaryOperator::Negate,
        rhs: Box::new(e),
        loc: Span { start, end }
    },
    Term
}


extern {
    type Location = usize;
    type Error = LexerError;

    enum Token {
        "." => Token::Period,
        "(" => Token::OpenParenthesis,
        ")" => Token::CloseParenthesis,
        "," => Token::Comma,
        "float" => Token::Float(<f64>),
        "int" => Token::Integer(<i64>),
        "uint" => Token::UInteger(<u64>),
        "bool" => Token::Boolean(<bool>),
        "string" => Token::String(<String>),
        "+" => Token::Operator(Operator::Plus),
        "-" => Token::Operator(Operator::Minus),
        "/" => Token::Operator(Operator::Divide),
        "*" => Token::Operator(Operator::Multiply),
        ">" => Token::Operator(Operator::GreaterThan),
        "<" => Token::Operator(Operator::LessThan),
        ">=" => Token::Operator(Operator::GreaterThanEquals),
        "<=" => Token::Operator(Operator::LessThanEquals),
        "==" => Token::Operator(Operator::Equals),
        "!=" => Token::Operator(Operator::NotEquals),
        "&&" => Token::Operator(Operator::And),
        "||" => Token::Operator(Operator::Or),
        "%" => Token::Operator(Operator::Modulo),
        "is" => Token::Operator(Operator::Is),
        "!" => Token::UnaryOperator(UnaryOperator::Negate),
        "null" => Token::TypeLiteral(crate::expressions::TypeLiteral::Null),
        "var" => Token::Identifier(<String>),
        "type" => Token::TypeLiteral(<crate::expressions::TypeLiteral>),
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        ":" => Token::Colon,
        ")=>" => Token::CombinedArrow,
        "=>" => Token::Arrow
    }
}
