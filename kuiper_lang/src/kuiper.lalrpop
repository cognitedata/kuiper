use crate::{
    lexer::Token,
    lexer::LexerError,
    parse::ast,
    expressions::{Operator, UnaryOperator},
};
use logos::Span;

grammar;

pub Program: ast::Program = {
    <m:Macros?> <e:Expr> => ast::Program {
        macros: m.unwrap_or_default(),
        expression: e
    }
}

Macro: ast::Macro = {
    "def" <v:"var"> ":=" <l:Lambda> => ast::Macro {
        name: v,
        body: l,
    }
}

Macros: Vec<ast::Macro> = {
    <v:(<Macro> ";")+> => v,
}

Const: ast::Constant = {
    <val:"uint"> => {
        ast::Constant::Integer(val)
    },
    <val:"string"> => {
        ast::Constant::String(val)
    },
    <val:"float"> => {
        ast::Constant::Float(val)
    },
    <val:"bool"> => {
        ast::Constant::Bool(val)
    },
    "null" => {
        ast::Constant::Null
    }
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Spanned<T>: (T, Span) = {
    <start:@L> <e:T> <end:@R> => (e, Span { start, end })
}

Lambda: ast::Lambda = {
    <start:@L> "(" <args: Comma<"var">> ")=>" <e: Expr> <end:@R> => ast::Lambda {
        args,
        inner: e,
        loc: Span { start, end }
    },
    <start:@L> <v:"var"> "=>" <e:Expr> <end:@R> => ast::Lambda {
        args: vec![v],
        inner: e,
        loc: Span { start, end }
    }
}

FunctionArg: ast::FunctionParameter = {
    <l: Lambda> => ast::FunctionParameter::Lambda(l),
    <e: Expr> => ast::FunctionParameter::Expression(e)
}

Expr: ast::Expression = Op2Expr;

ObjElem: ast::ObjectElementAst = {
    <lh:Expr> ":" <rh:Expr> => ast::ObjectElementAst::Pair(lh, rh),
    "..." <x:Expr> => ast::ObjectElementAst::Concat(x),
}

ArrElem: ast::ArrayElementAst = {
    <x:Expr> => ast::ArrayElementAst::Expression(x),
    "..." <x:Expr> => ast::ArrayElementAst::Concat(x),
}

Selector: ast::Selector = {
    "." <start:@L> <el:"var"> <end:@R> => ast::Selector::String(el, Span { start, end }),
    "[" <el:Expr> "]" => ast::Selector::Expression(Box::new(el))
}

Literal: String = {
    <fun:"var"> => fun,
    <fun:"type"> => fun.to_string()
}

IfFunc: ast::Expression = {
    <e: Term> "." <start:@L> "if" "(" <mut args:Comma<FunctionArg>> ")" <end:@R> => {
        args.insert(0, ast::FunctionParameter::Expression(e));
        ast::Expression::Function {
            name: "if".to_owned(),
            args,
            loc: Span { start, end }
        }
    },
    <start: @L> "if" "(" <arg: FunctionArg> "," <mut args:Comma<FunctionArg>> ")" <end:@R> => {
        args.insert(0, arg);
        ast::Expression::Function {
            name: "if".to_owned(),
            args,
            loc: Span { start, end }
        }
    }
}

IfExprInner: Vec<ast::Expression> = {
    "if" <cond: Expr> "{" <e: Expr> "}" => {
        vec![cond, e]
    },
    <mut lh:IfExprInner> "else" "if" <cond: Expr> "{" <e: Expr> "}" => {
        lh.push(cond);
        lh.push(e);
        lh
    }
}

IfExpr: ast::Expression = {
    <start: @L> <args: IfExprInner> <end:@R> => {
        ast::Expression::If {
            args,
            loc: Span { start, end }
        }
    },
    <start: @L> <mut args: IfExprInner> "else" "{" <e: Expr> "}" <end: @R> => {
        args.push(e);
        ast::Expression::If {
            args,
            loc: Span { start, end }
        }
    }
}

Term: ast::Expression = {
    <val:Spanned<Const>> => ast::Expression::Constant(val.0, val.1),
    <start:@L> <fun:Literal> "(" <args:Comma<FunctionArg>> ")" <end:@R> => ast::Expression::Function {
        name: fun,
        args,
        loc: Span { start, end }
    },
    <var:Spanned<"var">> => ast::Expression::Variable(var.0, var.1),
    <start:@L> "[" <it:Comma<ArrElem>> "]" <end:@R> => ast::Expression::Array(it, Span { start, end }),
    <start:@L> "{" <it:Comma<ObjElem>> "}" <end:@R> => ast::Expression::Object(it, Span { start, end }),
    <e: Term> "." <start:@L> <fun:Literal> "(" <mut args:Comma<FunctionArg>> ")" <end:@R> => {
        args.insert(0, ast::FunctionParameter::Expression(e));
        ast::Expression::Function {
            name: fun,
            args,
            loc: Span { start, end }
        }
    },
    <e: IfFunc> => e,
    <e: IfExpr> => e,
    <e: Term> <start:@L> <sel:Selector> <end:@R> => ast::Expression::Selector {
        lhs: Box::new(e),
        sel,
        loc: Span { start, end }
    },
    "(" <e:Expr> ")" => e
}

Tier<Op, NextTier>: ast::Expression = {
    <lhs:Tier<Op, NextTier>> <op:Spanned<Op>> <rhs:NextTier> => ast::Expression::BinaryOperation(ast::OpExpression {
        lhs: Box::new(lhs),
        operator: op.0,
        rhs: Box::new(rhs)
    }, op.1),
    NextTier
}

// From least to most important
Op2Expr = Tier<Op2, Op3Expr>;
Op2: Operator = {
    "||" => Operator::Or
}

Op3Expr = Tier<Op3, Op4Expr>;
Op3: Operator = {
    "&&" => Operator::And
}

Op4Expr = Tier<Op4, Op5Expr>;
Op4: Operator = {
    "==" => Operator::Equals,
    "!=" => Operator::NotEquals
}

TypeLiteral: crate::expressions::TypeLiteral = {
    <t:"type"> => t,
    "null" => crate::expressions::TypeLiteral::Null
}

Op5Expr: ast::Expression = {
    <lhs:Op5Expr> <op:Spanned<Op5>> <rhs:Op6Expr> => ast::Expression::BinaryOperation(ast::OpExpression {
        lhs: Box::new(lhs),
        operator: op.0,
        rhs: Box::new(rhs)
    }, op.1),
    <lhs:Op5Expr> "is" <rhs:TypeLiteral> => ast::Expression::Is(ast::IsExpression {
        lhs: Box::new(lhs),
        rhs,
        not: false
    }),
    <lhs:Op5Expr> "is" "not" <rhs:TypeLiteral> => ast::Expression::Is(ast::IsExpression {
        lhs: Box::new(lhs),
        rhs,
        not: true
    }),

    Op6Expr
}

Op5: Operator = {
    ">" => Operator::GreaterThan,
    "<" => Operator::LessThan,
    ">=" => Operator::GreaterThanEquals,
    "<=" => Operator::LessThanEquals,
}

Op6Expr = Tier<Op6, Op7Expr>;
Op6: Operator = {
    "+" => Operator::Plus,
    "-" => Operator::Minus
}

Op7Expr = Tier<Op7, Op8Expr>;
Op7: Operator = {
    "*" => Operator::Multiply,
    "/" => Operator::Divide,
    "%" => Operator::Modulo
}

UnaryOp: UnaryOperator = {
    "!" => UnaryOperator::Negate,
    "-" => UnaryOperator::Minus
}
Op8Expr: ast::Expression = {
    <op:Spanned<UnaryOp>> <e:Op8Expr> => ast::Expression::UnaryOperation {
        operator: op.0,
        rhs: Box::new(e),
        loc: op.1
    },
    Term
}


extern {
    type Location = usize;
    type Error = LexerError;

    enum Token {
        "." => Token::Period,
        "(" => Token::OpenParenthesis,
        ")" => Token::CloseParenthesis,
        "," => Token::Comma,
        "float" => Token::Float(<f64>),
        "uint" => Token::Integer(<u64>),
        "bool" => Token::Boolean(<bool>),
        "string" => Token::String(<String>),
        "+" => Token::Operator(Operator::Plus),
        "-" => Token::Operator(Operator::Minus),
        "/" => Token::Operator(Operator::Divide),
        "*" => Token::Operator(Operator::Multiply),
        ">" => Token::Operator(Operator::GreaterThan),
        "<" => Token::Operator(Operator::LessThan),
        ">=" => Token::Operator(Operator::GreaterThanEquals),
        "<=" => Token::Operator(Operator::LessThanEquals),
        "==" => Token::Operator(Operator::Equals),
        "!=" => Token::Operator(Operator::NotEquals),
        "&&" => Token::Operator(Operator::And),
        "||" => Token::Operator(Operator::Or),
        "%" => Token::Operator(Operator::Modulo),
        "is" => Token::Operator(Operator::Is),
        "if" => Token::If,
        "else" => Token::Else,
        "!" => Token::UnaryOperator(UnaryOperator::Negate),
        "null" => Token::TypeLiteral(crate::expressions::TypeLiteral::Null),
        "var" => Token::Identifier(<String>),
        "type" => Token::TypeLiteral(<crate::expressions::TypeLiteral>),
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        ":" => Token::Colon,
        ";" => Token::SemiColon,
        ":=" => Token::DefineEqual,
        ")=>" => Token::CombinedArrow,
        "=>" => Token::Arrow,
        "..." => Token::DotDot,
        "not" => Token::Not,
        "def" => Token::DefineSym,
    }
}
