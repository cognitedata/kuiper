# Kuiper - JSON transform language

This library defines a JSON to JSON transform and templating language. The language itself is
inspired by JavaScript. Expressions always terminate, as the language has no form of recursion.
This means that while there are loops, they only operate on input arrays. So it is possible to iterate over
an array, and even pairs of arrays, but it is not possible to implement recursion.

## Features

- **Operators**, `+`, `-`, `*`, `/`, `==`, `!=`, `>=`, `<=`, `>`, `<`, `&&`, `||` with precendence taken from the C++ standard.
- **Arrays**, `[1, 2, "test", 123.123, [123, 2]]`
- **Objects**, `{ "test": "123", concat("test", "test"): 321 }`
- **Built in functions**, like `map`, `float`, `concat`, etc. Either `pow(base, exp) or base.pow(exp)`
- **Functors**, `map` is a functor, meaning it accepts a lambda: `map(arr, field => ...)` or `arr.map(field => ...)`
- **Selector expressions**, `[1, 2, 3][1] == 2`, `input.field.value["dynamic"]`, etc.

## Usage

```rust
use kuiper_lang::compile_expression;
use serde_json::json;

let transform = compile_expression("input.value + 5", &["input"]).unwrap();

let input = [json!({ "value": 2 })];
let result = transform.run(input.iter()).unwrap();

assert_eq!(result.as_u64().unwrap(), 7);
```

## Design

This library contains part of a compiler:

 - `lexer` contains a lexer built on `Logos`, which converts the input to a sequence of spanned tokens. The first stage of the compilation outputs an iterator of `Result<Token, LexerError>`
 - `parse` contains glue code for a parser generated by `lalrpop`. The grammar file itself is `jsontf.lalrpop`. Here you will find the AST for the language, which is the output of the second stage of compilation.
 - `expressions` contains a large set of executable expressions. The executable tree is first build by `compiler/exec_tree.rs`.
 - `compiler/optimizer.rs` contains the fourth and final stage of the compiler, which attempts to execute each part of the program recursively. If this fails with a `source missing` error, we traverse its children recursively. If it fails with any other error, this is a compile-time error. If it succeeds, the expression is replaced by a constant. This stage also replaces the variable identifiers with indexes in the input array.

So in summary, an expression is produced from `raw input -> Token stream -> AST -> Expression tree -> Optimized tree`
